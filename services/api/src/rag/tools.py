from __future__ import annotations

import json
import zipfile
from pathlib import Path
from typing import Annotated, List, Tuple, TypedDict

from pydantic import Field
from yarl import URL
from langchain_core.tools import tool

from .results import Result
from ..config import TAVILY_API_KEY
from ..http import HTTPSessionSingleton

__all__ = (
    "TOOLS",
)


class TavilySearchResult(TypedDict):
    title: Annotated[str, Field(description="The title of the search result.")]
    url: Annotated[str, Field(description="The URL of the search result.")]
    content: Annotated[str, Field(description="A short description of the search result.")]
    score: Annotated[float, Field(description="The relevance score of the search result.")]


class TavilyResponse(TypedDict):
    """Response for a search request from the Tavily API."""

    query: Annotated[str, Field(description="The search query that was executed.")]
    answer: Annotated[str, Field(description="A short answer to the user's query, generated by an LLM.")]
    results: Annotated[List[TavilySearchResult], Field(description="A list of sorted search results, ranked by relevancy.")]
    response_time: Annotated[float, Field(description="Time in seconds it took to complete the request.")]


@tool
async def search(query: str) -> Result[TavilyResponse]:
    """Search the Internet for real-time information"""
    http = HTTPSessionSingleton()
    await http.prepare()

    data = {
        "query": query,
        "topic": "general",
        "search_depth": "advanced",
        "max_results": 2,
        "include_answer": True,
        "include_raw_content": False,
        "include_images": False,
    }

    async with http.session.post(
        "https://api.tavily.com/search",
        headers={
            "Authorization": f"Bearer {TAVILY_API_KEY}",
            "Content-Type": "application/json",
        },
        data=json.dumps(data),
    ) as response:
        response.raise_for_status()
        return Result(result=await response.json(encoding="utf-8"))


__BASE_OUTPUT_DIR = Path(__file__).parent.parent.parent.resolve() / "outputs"
__BASE_OUTPUT_DIR.mkdir(parents=True, exist_ok=True)
__BASE_OUTPUT_URL = URL("/api/outputs")


def join_output_path(path: str) -> Tuple[Path, URL]:
    p = Path(path)
    p = p.relative_to(p.anchor)  # Remove leading /

    return __BASE_OUTPUT_DIR / p, __BASE_OUTPUT_URL.joinpath(str(p))


@tool
def write_to_file(path: str, content: str) -> Result[Tuple[str, str]]:
    """Write UTF-8 text data to a file at the specified path.

    Returns a tuple with 2 values:
    - The absolute path to the file in the filesystem (LLMs should use this path when calling other tools).
    - The URL to the file in the API (this path should only be used to display to end-user).
    """
    file_path, file_url = join_output_path(path)
    if not file_path.is_relative_to(__BASE_OUTPUT_DIR):
        return Result(error="Cannot navigate outside of output directory")

    file_path.parent.mkdir(parents=True, exist_ok=True)
    with file_path.open("w", encoding="utf-8") as file:
        file.write(content)

    return Result(result=(str(file_path), str(file_url)))


@tool
def archive(path: str, files: List[str]) -> Result[Tuple[str, str]]:
    """Archive files into a zip file.

    Returns a tuple with 2 values:
    - The absolute path to the file in the filesystem (LLMs should use this path when calling other tools).
    - The URL to the file in the API (this path should only be used to display to end-user).
    """
    zip_path, zip_url = join_output_path(path)
    if not zip_path.is_relative_to(__BASE_OUTPUT_DIR):
        return Result(error="Cannot navigate outside of output directory")

    zip_path.parent.mkdir(parents=True, exist_ok=True)
    with zipfile.ZipFile(zip_path, "w") as archive:
        for file in files:
            actual_path, _ = join_output_path(file)
            archive.write(actual_path)

    return Result(result=(str(zip_path), str(zip_url)))


TOOLS = {
    "search": search,
    "write_to_file": write_to_file,
    "archive": archive,
}
